/**
 *
 * Copyright 2013
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * @author Kalyan Mulampaka
 */
package com.edgar.jdbc.codegen;

import com.google.common.base.CharMatcher;
import com.google.common.base.Splitter;
import com.google.common.base.Strings;
import com.google.common.collect.Iterables;

import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class BaseClass {
  final static Logger logger = LoggerFactory.getLogger(BaseClass.class);

  private static String COMMENT_START = "/* START 写在START和END中间的代码不会被替换*/";

  private static String COMMENT_END = "/* END 写在START和END中间的代码不会被替换*/";

  private static String IS_COMMENT_START = "/* START";

  private static String IS_COMMENT_END = "/* END";

  protected String dbProductName;

  protected String dbProductVersion;

  protected String rootFolderPath;

  protected String packageName;

  protected List<String> imports = new ArrayList<String>();

  //转换为驼峰的名字
  protected String name;

  protected String tableName;

  protected String classSuffix = "";

  protected String extendsClassName;

  protected String interfaceName;

  protected List<Field> fields;

  protected List<Method> methods;

  protected Map<String, ParameterType> pkeys = new HashMap<String, ParameterType>();

  protected StringBuffer userSourceBuf = new StringBuffer("");

  protected StringBuffer sourceBuf = new StringBuffer("");

  protected int fieldNameCounter = 0;

  public BaseClass() {

  }

  abstract public void generateSource();

  abstract protected void preprocess();

  abstract protected void addImports();

  public static StringBuffer generateClassComments() {
    StringBuffer strBuf = new StringBuffer("");
    strBuf.append("\n/**\n");
    strBuf.append(" * This class is generated by Jdbc code generator.\n");
    strBuf.append(" *\n");
    strBuf.append(" * @author Jdbc Code Generator\n");
    strBuf.append(" */\n");
    return strBuf;
  }

  public static String generateUserSourceCodeTags() {
    return COMMENT_START + "\n\n" + COMMENT_END + "\n\n";
  }

  public void createFile() throws Exception {
    String fileName = this.getSourceFileName();
    File file = new File(fileName);
    if (file.exists()) {
      logger.debug("File:{} exists, appending to existing file...", fileName);
      this.readUserSourceCode(file);
      //logger.debug ("User Source code:{}", this.userSourceBuf);
      this.userSourceBuf.toString();
    }

    FileWriter writer = new FileWriter(file);
    this.generateSource();
    writer.write(sourceBuf.toString());
    writer.close();
    logger.info("Class File created:" + fileName);
  }

  public StringBuffer getSourceBuf() {
    return this.sourceBuf;
  }

  public void setSourceBuf(StringBuffer sourceBuf) {
    this.sourceBuf = sourceBuf;
  }

  public String getRootFolderPath() {
    return this.rootFolderPath;
  }

  public void setRootFolderPath(String rootFolderPath) {
    this.rootFolderPath = rootFolderPath;
  }

  public String getPackageName() {
    return this.packageName;
  }

  public void setPackageName(String packageName) {
    this.packageName = packageName;
  }

  public List<String> getImports() {
    return this.imports;
  }

  public void setImports(List<String> imports) {
    this.imports = imports;
  }

  public String getName() {
    return this.name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public String getClassSuffix() {
    return this.classSuffix;
  }

  public void setClassSuffix(String classSuffix) {
    this.classSuffix = classSuffix;
  }

  public String getInterfaceName() {
    return this.interfaceName;
  }

  public void setInterfaceName(String interfaceName) {
    this.interfaceName = interfaceName;
    if (!Strings.isNullOrEmpty(this.interfaceName)) {
      this.imports.add(this.interfaceName);
    }
  }

  public List<Field> getFields() {
    return this.fields;
  }

  public void setFields(List<Field> fields) {
    this.fields = fields;
  }

  public List<Method> getMethods() {
    return this.methods;
  }

  public void setMethods(List<Method> methods) {
    this.methods = methods;
  }

  public String getExtendsClassName() {
    return this.extendsClassName;
  }

  public void setExtendsClassName(String extendsClassName) {
    this.extendsClassName = extendsClassName;
    if (!Strings.isNullOrEmpty(extendsClassName)) {
      this.imports.add(extendsClassName);
    }
  }

  public Map<String, ParameterType> getPkeys() {
    return this.pkeys;
  }

  public void setPkeys(Map<String, ParameterType> keys) {
    this.pkeys = keys;
  }

  public String getDbProductName() {
    return this.dbProductName;
  }

  public void setDbProductName(String dbProductName) {
    this.dbProductName = dbProductName;
  }

  public String getDbProductVersion() {
    return this.dbProductVersion;
  }

  public void setDbProductVersion(String dbProductVersion) {
    this.dbProductVersion = dbProductVersion;
  }

  public String getTableName() {
    return tableName;
  }

  public void setTableName(String tableName) {
    this.tableName = tableName;
  }

  public boolean containsFieldName(String name) {
    for (Field field : fields) {
      if (field.getHumpName().equals(name))
        return true;
    }
    return false;
  }

  protected void createLogger() {
//    this.imports.add("org.slf4j.LoggerFactory");
//    this.imports.add("org.slf4j.Logger");
  }

  protected void printPackage() {
    sourceBuf.append("package " + packageName + ";\n\n");
  }

  protected void printImports() {
//        this.imports.add("java.util.List");
//        this.imports.add("java.util.Map");
    if (!this.imports.isEmpty()) {
      for (String importClass : this.imports) {
        sourceBuf.append("import " + importClass + ";\n");
      }
    }
  }

  protected void printClassComments() {
    sourceBuf.append(generateClassComments());
  }

  protected void printOpenBrace(int indentLevel, int newLines) {
    for (int i = 0; i < indentLevel; i++) {
      sourceBuf.append("\t");
    }
    sourceBuf.append("{");
    if (newLines == 0)
      newLines = 1; // add atleast 1 new line
    for (int i = 0; i < newLines; i++) {
      sourceBuf.append("\n");
    }
  }

  protected void printLogger() {
    sourceBuf.append("\tfinal static Logger logger = LoggerFactory.getLogger (" + this.name +
                             this.classSuffix + ".class);\n\n");
  }

  protected void printClassDefn() {
    sourceBuf.append("public class " + name + this.classSuffix);
  }

  protected void printClassExtends() {
    if (!Strings.isNullOrEmpty(extendsClassName)) {
      String extendsClass = this.extendsClassName.substring(CharMatcher.anyOf(".").lastIndexIn
              (this.extendsClassName) + 1);
      sourceBuf.append(" extends " + extendsClass);
    }
  }

  protected void printClassImplements() {
    if (!Strings.isNullOrEmpty(interfaceName)) {
      String implementsClass = this.interfaceName.substring(CharMatcher.anyOf(".").lastIndexIn
              (this.interfaceName) + 1);
      sourceBuf.append(" implements " + implementsClass);
    }
    sourceBuf.append(" ");
  }

  protected void printCloseBrace(int indentLevel, int newLines) {
    for (int i = 0; i < indentLevel; i++) {
      sourceBuf.append("\t");
    }
    sourceBuf.append("}");
    for (int i = 0; i < newLines; i++) {
      sourceBuf.append("\n");
    }
  }

  protected void printCtor() {
    // no args constructor
    sourceBuf.append("\tpublic " + name + this.classSuffix + "() ");
    this.printOpenBrace(0, 2);
    this.printCloseBrace(1, 2);
  }

  protected String getSourceFileName() {
    String path = "";
    if (!Strings.isNullOrEmpty(this.packageName)) {
      path = CharMatcher.anyOf(".").replaceFrom(this.packageName, "/") + "/";
    }
    if (!Strings.isNullOrEmpty(this.rootFolderPath)) {
      path = this.rootFolderPath + "/" + path;
    }

    String fileName = path + name + classSuffix + ".java";
    return fileName;
  }

  protected void readUserSourceCode(File file) {
    try {
      logger.debug("Reading file :{}", file.getName());
      String contents = FileUtils.readFileToString(file);
      //logger.trace ("File contents:{}", contents);

      int startIndex = contents.indexOf(IS_COMMENT_START);
      int endIndex = contents.indexOf(IS_COMMENT_END);
      logger.debug("Start index:{} End index:{}", startIndex, endIndex);
      if (startIndex != -1 && endIndex != -1) {
        userSourceBuf.append(contents.substring(startIndex, endIndex));
        userSourceBuf.append(COMMENT_END + "\n\n");
      }
      // save the imports
      List<String> lines = FileUtils.readLines(file);
      for (String line : lines) {
        if (line.startsWith("import")) {
          String[] tokens = Iterables.toArray(Splitter.on(" ").split(line), String.class);
          if (tokens.length > 2) {
            String iClass = tokens[1] + " " + tokens[2].substring(0, tokens[2].length() - 1);
            logger.debug("iClass:{}", iClass);
            if (!this.imports.contains(iClass)) {
              this.imports.add(iClass);
            }
          } else {
            String iClass = tokens[1].substring(0, tokens[1].length() - 1);
            if (!this.imports.contains(iClass)) {
              this.imports.add(iClass);
            }
          }
        }
      }

    } catch (Exception e) {
      logger.error(e.getMessage());
    } finally {

    }

  }

  protected void printUserSourceCode() {
    String userSource = this.userSourceBuf.toString();
    if (Strings.isNullOrEmpty(userSource)) {
      this.sourceBuf.append(BaseClass.generateUserSourceCodeTags());
    } else {
      this.sourceBuf.append(userSource);
    }

  }

  public enum DATABASE {
    POSTGRESQL("PostgreSQL"),
    MYSQL("MySQL"),
    UNKNOWN("unknown");

    private String name;

    private DATABASE(String name) {
      this.name = name;
    }

    public static DATABASE getByName(String name) {
      for (DATABASE d : DATABASE.values()) {
        if (d.getName().equalsIgnoreCase(name))
          return d;
      }
      return UNKNOWN;
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

  }

}
